<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Why Fibers Make Sense For Meteor</title>

    <meta name="description" content="Why Fibers Make Sense For Meteor">
    <meta name="author" content="Ben Newman">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/benjamn.css" id="theme">
    <link rel="stylesheet" href="plugin/highlight/default.min.css">
    <link rel="stylesheet" type="text/css" href="css/overrides.css">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/xcode.css">

    <script src="plugin/highlight/highlight.min.js"></script>

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>
    <img class="branding" src="img/meteor-logo-mark-black-on-transparent.png" />

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <h1>Why Fibers Make Sense For Meteor</h1>
          <p>
            <a target="_blank" href="mailto:ben@meteor.com">Ben Newman</a>
            (<a target="_blank" href="https://www.meteor.com">Meteor</a>)<br>
            <!-- <code><a target="_blank" href="http://gotocon.com/chicago-2015">GOTO</a>;</code> -->
            <a target="_blank"
               href="http://gotocon.com/chicago-2015/presentation/Why%20Fibers%20Make%20Sense%20For%20Meteor">11 May 2015</a><br>
            <pre class="contact">
{ <a target="_blank" href="http://github.com/benjamn">github</a>,
  <a target="_blank" href="http://twitter.com/benjamn">twitter</a>,
  <a target="_blank" href="http://instagram.com/benjamn">instagram</a>,
  <a target="_blank" href="http://facebook.com/benjamn">facebook</a>
}.com/benjamn</pre>
          </p>
        </section>

        <section>
          <h2>
            How do<br>
            languages<br>
            change?
          </h2>
        </section>

        <section>
          <h2>
            How do<br>
            natural languages<br>
            change?
          </h2>
        </section>

        <section>
          <h2>
            How do<br>
            programming languages<br>
            change?
          </h2>
        </section>

        <section>
          <h2>
            How can<br>
            JavaScript<br>
            change?
          </h2>
        </section>

        <section>
          <h2>
            &ldquo;The Web is a brutal,<br>
            shortest-path, Worse-is-Better
            evolving system.&rdquo;
          </h2>
        </section>

        <section>
          <h2>
            JavaScript is finally<br>
            becoming the language<br>
            we want.
          </h2>
        </section>

        <section>
          <h2>
            Many new features can<br>
            be <em>simulated</em> without any<br>
            changes to the language.
          </h2>
          <p class="fragment">
            <code class="javascript block">
// ES6 Arrow function
[1, 3, 21, 10].sort((a, b) => a - b)
</code>
          </p>
          <p class="fragment">
            <code class="javascript block">
// ES5 Function expression
[1, 3, 21, 10].sort(function (a, b) {
  return a - b;
})
</code>
          </p>
        </section>

        <section>
          <h2>
            But not everything!
          </h2>
        </section>

        <section>
          <h2>
            Today I want to talk about a powerful feature that cannot be
            simulated in any reasonable way.
          </h2>
          <br>
          <p class="fragment">
            A &ldquo;reasonable&rdquo; translation must produce code that
            is readable, debuggable, and recognizable as JavaScript,
            rather than (say) generating bytecode that runs on a VM
            implemented in JavaScript.
          </p>
        </section>

        <section>
          <h2>
            And you can use this feature in Meteor today!
          </h2>
          <!-- <p class="fragment"> -->
          <!--   We believe this feature is more useful than -->
          <!--   dangerous,<span class="fragment"> but reasonable people hold -->
          <!--   the opposite opinion.</span> -->
          <!-- </p> -->
        </section>

        <section>
          <h1>
            Coroutines<span class="fragment">
              (<a target="_blank"
                  href="https://github.com/laverdet/node-fibers">Fibers</a>)
            </span>
          </h1>
          <br>
          <p class="fragment">
            Imagine if, instead of unwinding the stack, throwing an
            exception simply paused execution at the point where the
            exception was thrown, allowing other events to be processed by
            the event loop, and later you could resume execution from that
            point.
          </p>
        </section>

        <section>
          <h1>
            Coroutines
            (<a target="_blank"
                href="https://github.com/laverdet/node-fibers">Fibers</a>)
          </h1>
          <br>
          <code class="javascript block fragment left">
new Fiber(function () {
  console.log("before");
  sleep(1000);
  console.log("after");
}).run();</code>
          <code class="javascript block fragment right">
function sleep(ms) {
  var fiber = Fiber.current;
  setTimeout(fiber.run, ms);
  Fiber.yield();
}</code>
        </section>

        <section>
          <h1>
            Coroutines
            (<a target="_blank"
                href="https://github.com/laverdet/node-fibers">Fibers</a>)
          </h1>
          <br>
          <code class="javascript block left">
new Fiber(function () {
  console.log("before");
  sleep(1000); // Seemingly synchronous!
  console.log("after");
}).run();</code>
          <code class="javascript block right">
function sleep(ms) {
  var fiber = Fiber.current;
  setTimeout(fiber.run, ms);
  Fiber.yield();
}</code>
        </section>

        <section>
          <h2>
            Many other languages<br>
            support coroutines!
          </h2>
          <br>
          <p class="fragment">
            Aikido, AngelScript, BCPL, Pascal, BETA, BLISS, C#, ChucK, D,
            Dynamic C, Erlang, F#, Factor, GameMonkey Script, Go, Haskell,
            High Level Assembly, Icon, Io, Julia, Limbo, Lua, Lucid, ÂµC++,
            MiniD, Modula-2, Nemerle, Perl, PHP, Picolisp, Prolog, Python,
            Ruby, Rust, Sather, Scheme, Self, Simula 67, Squirrel,
            Stackless Python, SuperCollider, Tcl, urbiscript
          </p>
        </section>

        <section>
          <h2>
            Why not JavaScript?
          </h2>
        </section>

        <section class="external_iframe">
          <h2>Dave Herman (Mozilla, TC39):</h2>
          <iframe class="fragment"
                  src="http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web"></iframe>
        </section>

        <section>
          <h2>
            Programming language design is as much about saying
            &ldquo;no&rdquo; to tempting features as it is about saying
            &ldquo;yes.&rdquo;
          </h2>
        </section>

        <section>
          <h2>
            If we can agree that making asynchronous programming easier is
            important for the future of JavaScript,<span class="fragment">
            and TC39 is not interested in
            coroutines,<span class="fragment"> then what other remedy do
            they have in mind?</span></span>
          </h2>
        </section>

        <section>
          <h1>
            <code class="javascript">async</code> and
            <code class="javascript">await</code>
          </h1>
          <div class="align-left">
            <code class="javascript small block fragment">
async function createUser(name) {
  let response = await users.insert({ name: name });
  return await users.findOne(response._id);
}</code>
            <code class="javascript small block fragment">
async function getOrCreateUser(name) {
  let user = await users.findOne({ name: name });
  return user || await createUser(name);
}</code>
            <code class="javascript small block fragment">
getOrCreateUser("ben").then(function (ben) {
  console.log(ben.name);
});</code>
          </div>
          <p class="fragment">
            Planned for ES7, available today via <a target="_blank"
            href="https://github.com/facebook/regenerator">Regenerator</a>
            (ES3+) or <a target="_blank"
            href="https://www.npmjs.com/package/es7-async-await">es7-async-await</a>
            (ES6+).
          </p>
        </section>

        <section>
          <section>
            <h2>
              Let's try that with pure promises...
            </h2>
            <div class="align-left">
              <code class="javascript small block fragment">
async function createUser(name) {
  let response = await users.insert({ name: name });
  return await users.findOne(response._id);
}

async function getOrCreateUser(name) {
  let user = await users.findOne({ name: name });
  return user || await createUser(name);
}

getOrCreateUser("ben").then(function (ben) {
  console.log(ben.name);
});

              </code>
            </div>
            <p class="hidden">
              Slightly more boilerplate, though imagine
              if <code class="javascript">await</code>
              appeared inside a loop!
            </p>
          </section>

          <section>
            <h2>
              Let's try that with pure promises...
            </h2>
            <div class="align-left">
              <code class="javascript small block">
function createUser(name) {
  return users.insert({ name: name }).then(function (response) {
    return users.findOne(response._id);
  });
}

async function getOrCreateUser(name) {
  let user = await users.findOne({ name: name });
  return user || await createUser(name);
}

getOrCreateUser("ben").then(function (ben) {
  console.log(ben.name);
});
              </code>
            </div>
            <p class="hidden">
              Slightly more boilerplate, though imagine
              if <code class="javascript">await</code>
              appeared inside a loop!
            </p>
          </section>

          <section>
            <h2>
              Let's try that with pure promises...
            </h2>
            <div class="align-left">
              <code class="javascript small block">
function createUser(name) {
  return users.insert({ name: name }).then(function (response) {
    return users.findOne(response._id);
  });
}

function getOrCreateUser(name) {
  return users.findOne({ name: name }).then(function (user) {
    return user || createUser(name);
  });
}

getOrCreateUser("ben").then(function (ben) {
  console.log(ben.name);
});</code>
            </div>
            <p class="fragment">
              Slightly more boilerplate, though imagine
              if <code class="javascript">await</code>
              appeared inside a loop!
            </p>
          </section>
        </section>

        <section>
          <section>
            <h2>
              What about callbacks?
            </h2>
            <div class="align-left">
              <code class="javascript small block fragment">
function createUser(name) {
  return users.insert({ name: name }).then(function (response) {
    return users.findOne(response._id);
  });
}

function getOrCreateUser(name) {
  return users.findOne({ name: name }).then(function (user) {
    return user || createUser(name);
  });
}








              </code>
            </div>
          </section>

          <section>
            <h2>
              What about callbacks?
            </h2>
            <div class="align-left">
              <code class="javascript small block">
function createUser(name, callback) {
  users.insert({ name: name }).then(function (response) {
    users.findOne(response._id).then(function (user) {
      callback(null, user);
    }, function (error) {
      callback(error);
    });
  }, function (error) {
    callback(error);
  });
}

function getOrCreateUser(name) {
  return users.findOne({ name: name }).then(function (user) {
    return user || createUser(name);
  });
}


              </code>
            </div>
          </section>

          <section>
            <h2>
              What about callbacks?
            </h2>
            <div class="align-left">
              <code class="javascript small block">
function createUser(name, callback) {
  users.insert({ name: name }).then(function (response) {
    users.findOne(response._id).then(function (user) {
      callback(null, user);
    }, function (error) {
      callback(error);
    });
  }, function (error) {
    callback(error);
  });
}

function getOrCreateUser(name, callback) {
  users.findOne({ name: name }).then(function (user) {
    if (user) callback(null, user);
    else createUser(name, callback);
  }, function (error) {
    callback(error);
  });
}</code>
            </div>
          </section>
        </section>

        <section>
          <h1>
            We've come so far!
          </h1>
        </section>

        <section>
          <h1>
            Can we do better?
          </h1>
        </section>

        <section>
          <section>
            <h2>
              If JavaScript had coroutines, we could
              implement <code class="javascript">async</code>
              and <code class="javascript">await</code> without any new
              syntax.
            </h2>
            <div class="align-left fragment">
              <code class="javascript small block">
async function createUser(name) {
  let response = await users.insert({ name: name });
  return await users.findOne(response._id);
}

async function getOrCreateUser(name) {
  let user = await users.findOne({ name: name });
  return user || await createUser(name);
}</code>
            </div>
            <p class="hidden">
              Just function calls!
            </p>
          </section>

          <section>
            <h2>
              If JavaScript had coroutines, we could
              implement <code class="javascript">async</code>
              and <code class="javascript">await</code> without any new
              syntax.
            </h2>
            <div class="align-left">
              <code class="javascript small block">
let createUser = async(function (name) {
  let response = await users.insert({ name: name });
  return await users.findOne(response._id);
});

async function getOrCreateUser(name) {
  let user = await users.findOne({ name: name });
  return user || await createUser(name);
}</code>
            </div>
            <p class="hidden">
              Just function calls!
            </p>
          </section>

          <section>
            <h2>
              If JavaScript had coroutines, we could
              implement <code class="javascript">async</code>
              and <code class="javascript">await</code> without any new
              syntax.
            </h2>
            <div class="align-left">
              <code class="javascript small block">
let createUser = async(function (name) {
  let response = await(users.insert({ name: name }));
  return await users.findOne(response._id);
});

async function getOrCreateUser(name) {
  let user = await users.findOne({ name: name });
  return user || await createUser(name);
}</code>
            </div>
            <p class="hidden">
              Just function calls!
            </p>
          </section>

          <section>
            <h2>
              If JavaScript had coroutines, we could
              implement <code class="javascript">async</code>
              and <code class="javascript">await</code> without any new
              syntax.
            </h2>
            <div class="align-left">
              <code class="javascript small block">
let createUser = async(function (name) {
  let response = await(users.insert({ name: name }));
  return await(users.findOne(response._id));
});

async function getOrCreateUser(name) {
  let user = await users.findOne({ name: name });
  return user || await createUser(name);
}</code>
            </div>
            <p class="hidden">
              Just function calls!
            </p>
          </section>

          <section>
            <h2>
              If JavaScript had coroutines, we could
              implement <code class="javascript">async</code>
              and <code class="javascript">await</code> without any new
              syntax.
            </h2>
            <div class="align-left">
              <code class="javascript small block">
let createUser = async(function (name) {
  let response = await(users.insert({ name: name }));
  return await(users.findOne(response._id));
});

let getOrCreateUser = async(function (name) {
  let user = await users.findOne({ name: name });
  return user || await createUser(name);
});</code>
            </div>
            <p class="hidden">
              Just function calls!
            </p>
          </section>

          <section>
            <h2>
              If JavaScript had coroutines, we could
              implement <code class="javascript">async</code>
              and <code class="javascript">await</code> without any new
              syntax.
            </h2>
            <div class="align-left">
              <code class="javascript small block">
let createUser = async(function (name) {
  let response = await(users.insert({ name: name }));
  return await(users.findOne(response._id));
});

let getOrCreateUser = async(function (name) {
  let user = await(users.findOne({ name: name }));
  return user || await createUser(name);
});</code>
            </div>
            <p class="hidden">
              Just function calls!
            </p>
          </section>

          <section>
            <h2>
              If JavaScript had coroutines, we could
              implement <code class="javascript">async</code>
              and <code class="javascript">await</code> without any new
              syntax.
            </h2>
            <div class="align-left">
              <code class="javascript small block">
let createUser = async(function (name) {
  let response = await(users.insert({ name: name }));
  return await(users.findOne(response._id));
});

let getOrCreateUser = async(function (name) {
  let user = await(users.findOne({ name: name }));
  return user || await(createUser(name));
});</code>
            </div>
            <p class="fragment">
              Just function calls!
            </p>
          </section>
        </section>

        <section>
          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block fragment">
function await(argument) {














}</code>
            </div>
          </section>

          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block">
function await(argument) {
  var fiber = Fiber.current;













}</code>
            </div>
          </section>

          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block">
function await(argument) {
  var fiber = Fiber.current;

  assert.ok(
    fiber instanceof Fiber,
    "Cannot await without a Fiber"
  );








}</code>
            </div>
          </section>

          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block">
function await(argument) {
  var fiber = Fiber.current;

  assert.ok(
    fiber instanceof Fiber,
    "Cannot await without a Fiber"
  );







  return Fiber.yield();
}</code>
            </div>
          </section>

          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block">
function await(argument) {
  var fiber = Fiber.current;

  assert.ok(
    fiber instanceof Fiber,
    "Cannot await without a Fiber"
  );

  Promise.resolve(argument)





  return Fiber.yield();
}</code>
            </div>
          </section>

          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block">
function await(argument) {
  var fiber = Fiber.current;

  assert.ok(
    fiber instanceof Fiber,
    "Cannot await without a Fiber"
  );

  Promise.resolve(argument).then(function (result) {

  }, function (error) {

  });

  return Fiber.yield();
}</code>
            </div>
          </section>

          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block">
function await(argument) {
  var fiber = Fiber.current;

  assert.ok(
    fiber instanceof Fiber,
    "Cannot await without a Fiber"
  );

  Promise.resolve(argument).then(function (result) {
    fiber.run(result);
  }, function (error) {

  });

  return Fiber.yield();
}</code>
            </div>
          </section>

          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block">
function await(argument) {
  var fiber = Fiber.current;

  assert.ok(
    fiber instanceof Fiber,
    "Cannot await without a Fiber"
  );

  Promise.resolve(argument).then(function (result) {
    fiber.run(result);
  }, function (error) {
    fiber.throwInto(error);
  });

  return Fiber.yield();
}</code>
            </div>
          </section>

          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block">
function async(fn) {














}</code>
            </div>
          </section>

          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block">
function async(fn) {
  return function () {












  };
}</code>
            </div>
          </section>

          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block">
function async(fn) {
  return function () {
    var self = this;
    var args = arguments;










  };
}</code>
            </div>
          </section>

          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block">
function async(fn) {
  return function () {
    var self = this;
    var args = arguments;

    return new Promise(function (resolve, reject) {







    });
  };
}</code>
            </div>
          </section>

          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block">
function async(fn) {
  return function () {
    var self = this;
    var args = arguments;

    return new Promise(function (resolve, reject) {
      new Fiber(function () {





      })
    });
  };
}</code>
            </div>
          </section>

          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block">
function async(fn) {
  return function () {
    var self = this;
    var args = arguments;

    return new Promise(function (resolve, reject) {
      new Fiber(function () {

                  fn.apply(self, args)



      })
    });
  };
}</code>
            </div>
          </section>

          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block">
function async(fn) {
  return function () {
    var self = this;
    var args = arguments;

    return new Promise(function (resolve, reject) {
      new Fiber(function () {

          resolve(fn.apply(self, args));



      })
    });
  };
}</code>
            </div>
          </section>

          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block">
function async(fn) {
  return function () {
    var self = this;
    var args = arguments;

    return new Promise(function (resolve, reject) {
      new Fiber(function () {
        try {
          resolve(fn.apply(self, args));
        } catch (error) {

        }
      })
    });
  };
}</code>
            </div>
          </section>

          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block">
function async(fn) {
  return function () {
    var self = this;
    var args = arguments;

    return new Promise(function (resolve, reject) {
      new Fiber(function () {
        try {
          resolve(fn.apply(self, args));
        } catch (error) {
          reject(error);
        }
      })
    });
  };
}</code>
            </div>
          </section>

          <section>
            <h2>How might these magical functions be implemented?</h2>
            <div class="align-left">
              <code class="javascript small block">
function async(fn) {
  return function () {
    var self = this;
    var args = arguments;

    return new Promise(function (resolve, reject) {
      new Fiber(function () {
        try {
          resolve(fn.apply(self, args));
        } catch (error) {
          reject(error);
        }
      }).run();
    });
  };
}</code>
            </div>
          </section>
        </section>

        <section>
          <h2>
            Once we have these two functions in our
            toolchain,<span class="fragment"> we can forget they were
            implemented
            using <code class="javascript">Fiber</code>s,<span class="fragment">
            just as I forgot to mention that <a target="_blank"
            href="https://github.com/laverdet/node-fibers"><code>node-fibers</code></a>
            is implemented on top of <a target="_blank"
            href="http://software.schmorp.de/pkg/libcoro.html"><code>libcoro</code></a>.</span></span>
          </h2>
        </section>

        <section>
          <section>
            <h2>
              These two functions are more powerful than they seem.
            </h2>
            <div class="align-left">
              <code class="javascript small block fragment">
let createUser = async(function (name) {
  let response = await(users.insert({ name: name }));
  return await(users.findOne(response._id));
});

let getOrCreateUser = async(function (name) {
  let user = await(users.findOne({ name: name }));
  return user || await(createUser(name));
});</code>
            </div>
            <p class="fragment">
              How many of these function calls are really necessary?
              Let's try removing some...
            </p>
          </section>

          <section>
            <h2>
              These two functions are more powerful than they seem.
            </h2>
            <div class="align-left">
              <code class="javascript small block">
function createUser(name) {
  let response = await(users.insert({ name: name }));
  return await(users.findOne(response._id));
}

let getOrCreateUser = async(function (name) {
  let user = await(users.findOne({ name: name }));
  return user || await(createUser(name));
});</code>
            </div>
            <p>
              Those <code class="javascript">await</code> calls
              in <code class="javascript">createUser</code> are legal as
              long as some <code class="javascript">async</code> function
              is on the call stack.
            </p>
          </section>

          <section>
            <h2>
              These two functions are more powerful than they seem.
            </h2>
            <div class="align-left">
              <code class="javascript small block">
function createUser(name) {
  let response = await(users.insert({ name: name }));
  return await(users.findOne(response._id));
}

let getOrCreateUser = async(function (name) {
  let user = await(users.findOne({ name: name }));
  return user || createUser(name);
});</code>
            </div>
            <p>
              Since <code class="javascript">createUser</code> no longer
              returns a <code class="javascript">Promise</code>,
              <code class="javascript">getOrCreateUser</code> no longer
              needs to <code class="javascript">await</code> it.
            </p>
          </section>

          <section>
            <h2>
              These two functions are more powerful than they seem.
            </h2>
            <div class="align-left">
              <code class="javascript small block">
function createUser(name) {
  let response = await(users.insert({ name: name }));
  return await(users.findOne(response._id));
}

let getOrCreateUser = async(function (name) {
  let user = await(users.findOne({ name: name }));
  return user || createUser(name);
});</code>
            </div>
            <p>
              In fact, if you're willing to adopt the practice of running
              all your code in a <code class="javascript">Fiber</code>...
            </p>
          </section>

          <section>
            <h2>
              These two functions are more powerful than they seem.
            </h2>
            <div class="align-left">
              <code class="javascript small block">
function createUser(name) {
  let response = await(users.insert({ name: name }));
  return await(users.findOne(response._id));
}

function getOrCreateUser(name) {
  let user = await(users.findOne({ name: name }));
  return user || createUser(name);
}</code>
            </div>
            <p>
              ... you don't even necessarily have to
              wrap <code class="javascript">getOrCreateUser</code> as
              an <code class="javascript">async</code> function!
            </p>
          </section>

          <section>
            <h2>
              These two functions are more powerful than they seem.
            </h2>
            <div class="align-left">
              <code class="javascript small block">
function createUser(name) {
  let response = await(users.insert({ name: name }));
  return await(users.findOne(response._id));
}

function getOrCreateUser(name) {
  let user = await(users.findOne({ name: name }));
  return user || createUser(name);
}</code>
            </div>
            <p>
              In this coding style,
              the <code class="javascript">await</code> function becomes a
              tool for evaluating promises &ldquo;synchronously.&rdquo;
            </p>
          </section>
        </section>

        <section>
          <h2>
            It can still be valuable to mark functions
            as <code class="javascript">async</code>, so that they can run
            in parallel.
          </h2>
          <code class="javascript block fragment">
let [ben, marley] = await Promise.all([
  getOrCreateUser("ben"),
  getOrCreateUser("marley")
]);
          </code>
          <p class="fragment">
            If <code class="javascript">getOrCreateUser</code>
            is <code class="javascript">async</code>, then it returns
            a <code class="javascript">Promise</code>, so
            <code class="javascript">marley</code> need not wait for
            <code class="javascript">ben</code>.
          </p>
        </section>

        <section>
          <h2>
            If you need your code to work in an environment without
            <code class="javascript">Fiber</code>s, it's best to provide a
            pure-<code class="javascript">Promise</code> API, and think
            of <code class="javascript">await</code> as a convenience
            that happens to be available on the server.
          </h2>
        </section>

        <section>
          <h1>Summary</h1>
          <br>
          <p class="fragment">
            You can think of coroutines as a <em>relaxation</em> of the
            ES7 <code class="javascript">async</code>
            and <code class="javascript">await</code>
            syntax,<span class="fragment"> in which
            <code class="javascript">await</code> is allowed to appear in
            the body of any function called within
            a <code class="javascript">Fiber</code>,<span class="fragment">
            instead of being restricted to the bodies of functions that
            are explicitly marked
            <code class="javascript">async</code>.
            </span></span>
          </p>
        </section>

        <section>
          <h1>Summary</h1>
          <br>
          <p class="fragment">
            This is great news for a framework like
            Meteor,<span class="fragment"> because we can wrap our
            top-level request and event handlers
            in <code class="javascript">Fiber</code>s<span class="fragment">,
            then use <code class="javascript">await</code> to implement
            certain asynchronous library
            operations,<span class="fragment"> and none of the code in
            between has to know about coroutines at
            all.</span></span></span>
          </p>
        </section>

        <section>
          <h1>Summary</h1>
          <br>
          <p class="fragment">
            Best of all,<span class="fragment"> the adoption of
            ES7 <code class="javascript">async</code>
            and <code class="javascript">await</code> means we will not
            need any new syntax if we ever decide to adopt
            coroutines,<span class="fragment"> because anything you might
            want to do with coroutines can be expressed in terms
            of <code class="javascript">async</code>
            and <code class="javascript">await</code>,<span class="fragment">
            just with slightly relaxed rules about
            where <code class="javascript">await</code> can legally
            appear.</span></span></span>
          </p>
        </section>

        <section>
          <h1>There has to be a catch, right?</h1>
        </section>

        <section>
          <h2>
            Catch #1:<span class="fragment"> Fibers are server-only</span>
          </h2>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>
    <script src="js/init.js"></script>
  </body>
</html>
